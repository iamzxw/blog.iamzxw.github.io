---
layout:     post
title:      剑指Offer刷一刷（一）/ 栈 Stack
subtitle:   刷完剑指Offer，#副标题
date:       2019-4-5 				# 时间
author:     zhu.xinwei 		    	# 作者
header-img: img/post-bg-desk.jpg	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 交叉熵
    - DenseNet
    - 
---

___
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

```c++
// c++代码
//思路:
// 时间复杂度为O(1) 不能用常规的排序、冒泡查找方法，可以借助stack完成;
// 加入一个辅助stack2, 
// push操作：stack1肯定要正常push；如果value <= stack2.top(), stack2.push操作；这样辅助stack2的top数值，一直是stack1中的最小值
// pop操作：如果两个stack的top数值相等，同时pop；stack1肯定要正常pop
class Solution {
public:
    stack<int> stack1,stack2;
    void push(int value) {
        stack1.push(value);
        if (stack2.empty())
            stack2.push(value);
        else if (value <= stack2.top())
            stack2.push(value);
            
    }
    void pop() {
        if (stack1.top() == stack2.top())
            stack2.pop();
        stack1.pop();
    }
    int top() {
        return stack1.top();
    }
    int min() {
        return stack2.top();
    }
};

```

___
输入两个整数序列，第一个序列表示栈的*压入顺序*，请判断第二个序列是否可能为该栈的*弹出顺序*。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

```c++
//思路：
// 既然给出了压栈顺序，我们就使用一个辅助栈stack按照顺序压入;
// 在每次push操作时，都尝试进行出栈操作，看看与弹出序列是够一致；
// 全部训练结束后，如果辅助栈为空，说明弹出顺序合法；
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        if (pushV.size() == 0) return false;
        //模拟真实入栈
        stack<int> s;
        //记录弹出序列移动指针
        int popIndex = 0;
        //遍历压入顺序，进行入栈
        for(int i =0; i<pushV.size(); ++i){
            s.push(pushV[i]);
            //如果辅助Stack的top数值与弹出序列一致，双方都消除一个数值
            while(popIndex < popV.size() && s.top() == popV[popIndex]){
                s.pop();
                popIndex++;
            }
        }
        return s.empty();
    }
};

```


___
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
/*
思路：
二叉树的层次遍历：借助队列完成，队列特征，先进先出：

先让根节点入队：-->root-->
然后循环：
    让左右子节点入队：right --> left --> root
    pop弹出

队列里的顺序就是层次遍历顺序,将队列一个一个弹出

*/
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        
        //先让root节点入队，确保队不为空
        if(root) 
            q.push(root);
        
        while(!q.empty()){
            //将队列一个一个弹出，队列里的顺序就是层次遍历顺序
            res.push_back(q.front()->val);
            //将左右子节点入队
            if(q.front()->left)
                q.push(q.front()->left);
            if(q.front()->right)
                q.push(q.front()->right);
            //队头的价值利用完了，弹出
            q.pop();
        }
        return res;
    }
};
```

___
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
```c++

/*
思路：
二叉搜索树的特征：左节点数值都比跟节点小，右节点数值都比根加点大；
对应到二叉搜索树的后续遍历上就是，数组最后一个值为根节点，前面n-1个值可以从中间某个地方截断，
前半部分数值都比根节点小，后半部分都比跟节点大；

非递归实现：
*/

class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        int size = sequence.size();
        if(0==size)
            return false;
        int i = 0; //用来从0到size，移动指示
        while(--size){
            //如果sequence[size]为数组最后一个数，则，sequence[i++]正好遍历左子树
            //如果sequence[size]为数组倒数第二个数，则，右子树>根节点>左子树，有重复计算
            while(sequence[i++] < sequence[size]);// i++;
            
            //大于根节点的，正好是右子树
            while(sequence[i++] > sequence[size]);// i++;
            
            //说明，左子树中有大于根节点sequence[size]的值，或者右子树中有小于....
            if(i<size) return false;
            i = 0;
        }
        return true;
    }
};


// 递归实现：

class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        if(!sequence.size()) return false;
        
        return judge(sequence, 0, sequence.size()-1);
    }
    
    bool judge(vector<int>& s, int l, int r){
        //递归到子节点后，都没有问题，返回ture
        if(l>=r) return true;
        
        int i = r;
        //右子树, 找到
        while(i>l && s[i-1] > s[r]) i--;
        //while(i>l && s[i-1] < s[r]) i--;
        for(int j = i-1; j>=l; --j)
            if(s[j] > s[r])
                return false;
        //i-1 去掉左子树根节点，r-1去掉根节点
        return judge(s, l, i-1) && judge(s, i, r-1);
        //左子树
        
    }
```