---
layout:     post
title:      剑指Offer刷一刷（一）/ 栈 Stack
subtitle:   刷完剑指Offer，#副标题
date:       2019-4-5 				# 时间
author:     zhu.xinwei 		    	# 作者
header-img: img/post-bg-desk.jpg	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 交叉熵
    - DenseNet
    - 
---

> 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。


```c++
// c++代码
//思路:
// 时间复杂度为O(1) 不能用常规的排序、冒泡查找方法，可以借助stack完成;
// 加入一个辅助stack2, 
// push操作：stack1肯定要正常push；如果value <= stack2.top(), stack2.push操作；这样辅助stack2的top数值，一直是stack1中的最小值
// pop操作：如果两个stack的top数值相等，同时pop；stack1肯定要正常pop
class Solution {
public:
    stack<int> stack1,stack2;
    void push(int value) {
        stack1.push(value);
        if (stack2.empty())
            stack2.push(value);
        else if (value <= stack2.top())
            stack2.push(value);
            
    }
    void pop() {
        if (stack1.top() == stack2.top())
            stack2.pop();
        stack1.pop();
    }
    int top() {
        return stack1.top();
    }
    int min() {
        return stack2.top();
    }
};

```

> 输入两个整数序列，第一个序列表示栈的*压入顺序*，请判断第二个序列是否可能为该栈的*弹出顺序*。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

```c++
//思路：
// 既然给出了压栈顺序，我们就使用一个辅助栈stack按照顺序压入;
// 在每次push操作时，都尝试进行出栈操作，看看与弹出序列是够一致；
// 全部训练结束后，如果辅助栈为空，说明弹出顺序合法；
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        if (pushV.size() == 0) return false;
        //模拟真实入栈
        stack<int> s;
        //记录弹出序列移动指针
        int popIndex = 0;
        //遍历压入顺序，进行入栈
        for(int i =0; i<pushV.size(); ++i){
            s.push(pushV[i]);
            //如果辅助Stack的top数值与弹出序列一致，双方都消除一个数值
            while(popIndex < popV.size() && s.top() == popV[popIndex]){
                s.pop();
                popIndex++;
            }
        }
        return s.empty();
    }
};

```

